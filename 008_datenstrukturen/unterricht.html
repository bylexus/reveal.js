{% extends "../_base_template.html" %}
{% block title %}Lektion 8 - Datenstrukturen{% endblock %}

{% block sections %}
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Lektion 8 - Stack und Vector-Klasse
=============================

Ziele für die Lektion

* Sie können Arrays in Java anwenden
* Sie verstehen die Komplexität von Einfügen / Entfernen-Operationen mit Arrays
* Sie kennen die Java-Klasse "Vector"

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> HA: Implementation Stack
=============================

Wir sehen uns eine Implementation Ihres Stack an. Wie haben Sie die Funktionen

* **push()**
* **pop()**
* **isEmpty()**

umgesetzt?
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Implementation Stack: Problematik Array
=============================

Wir haben in unserem Stack als Datenspeicher für die Elemente einen Array verwendet.
Was passiert aber nun, wenn unser Array voll ist?

<i class="far fa-hand-point-right"></i> Wir erinnern uns an eine Aussage aus einer früheren Lektion:

**Arrays sind**:

* mühsam, wenn man nicht genau weiss, wieviele Elemente zu speichern sind
* mühsam, wenn man einzelne Elemente einfügen oder entfernen muss
* super, wenn man auf Elemente zugreifen muss (nach Index)

<i class="far fa-hand-point-right"></i> Der Array scheint also als Datenstruktur absolut ungeeignet für den Stack!

</textarea>
</section>


<section data-markdown >
<textarea data-template>
<i class="fas fa-flask"></i> Implementation Stack: Verkleinern / Vergrössern
=============================

Unser Stack hat den Nachteil, dass er eine vorgegeben Grösse hat - irgendwann ist der Stack also "voll".
Um dieses Problem zu beheben, wollen wir nun Funktionen hinzufügen, welche den Stack vergrössern / verkleinern können.

Programmieren Sie folgende Funktionen in Java in Ihrer Stack-Klasse:

```java
int[] enlarge(int[] arr, int newSize) {
    // erzeugt einen neuen Array mit Grösse newSize, und gibt einen neuen Array mit
    // allen Werten aus dem alten Array zurück.
}

int[] shrink(int[] arr, int newSize) {
    // erzeugt einen neuen Array mit Grösse newSize, und gibt einen neuen Array mit
    // allen Werten aus dem alten Array zurück, soviel wie platz haben.
}
```

Rufen Sie dann Ihre Funktionen an der entsprechenden Stelle in Ihrer Stack-Klasse auf. Wo muss dies passieren?
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-flask"></i> Implementation Stack: Verkleinern / Vergrössern
=============================

Das Hantieren mit den Arrays scheint recht mühsam, nicht?

* Vergrössern / Verkleinern ist aufwändig
* Elemente einfügen ist mühsam
* Elemente entfernen ist mühsam

Das muss doch einfacher gehen! Wie würden Sie dies lösen?
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-flask"></i> Einführung Vector-Klasse
=============================

Im Fall vom Stack sehe ich folgende Möglichkeiten:

1. Array ist die falsche Datenstruktur dafür - Ist eine Linked List nicht viel geeigneter?
<i class="far fa-hand-point-right"></i> Übung dazu folgt gleich!
2. Glücklicherweise gibt es bereits vorgefertigte Datenstrukturen von Java, welche uns
   helfen, mit Arrays umzugehen - Eine davon ist die Klasse **Vector**, welche wir uns nun im Detail anschauen.
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-flask"></i> Einführung Vector-Klasse
=============================

Die Klasse **Vector** aus der **Java Collection API** (siehe https://docs.oracle.com/javase/7/docs/api/java/util/Vector.html)

Auszug aus der Doku:

> The Vector class implements a **growable array of objects**. Like an array, it contains components that can be accessed using
an integer index. However, the size of a Vector can grow or shrink as needed to accommodate adding and removing items after
the Vector has been created.

Das tönt doch gut! Java bietet uns hier also eine **Datenstruktur**, welche uns die mühsame Arbeit mit Arrays abnimmt!

**Verwendung von Vector am Beispiel**

```java
// Vector ist eine so genannte generische Container-Klasse: Man muss ihr sagen,
// welche Art (Klasse) von Objekten sie speichern soll (Hier: Integer):
Vector<Integer> v = new Vector<>();

// Einfügen von Elementen, unabhängig von der internen Array-Gröse:
v.add(1);
v.add(2);
v.add(3);
v.add(4);

// Einfügen von Elementen an bestimmten Index:
v.add(2,5); // fügt 5 an Index 2 ein

// Entfernen von Elementen:
v.remove(2); // entfernt Element an Index 2

// Wieviele Elemente sind gespeichert?
v.size();

// Wie gross ist der interne Array?
v.capacity();
```

**Vector** ist eine Klasse der Java Collections API. Wir werden diese im Detail in einer späteren Lektion kennen lernen.

**Übung / Hausaufgabe:**

Bauen Sie die Klasse **Stack** so um, dass sie intern ein Vector-Objekt anstelle eines Arrays verwendet!
</textarea>
</section>
{% endblock %}
