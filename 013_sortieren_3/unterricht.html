{% extends "../_base_template.html" %}
{% block title %}Lektion 13 - Sortieren{% endblock %}

{% block sections %}
<section data-markdown>
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Lektion 13 - Sortieren mit der Collection API
=============================

**Ziele:**

* Sie kennen das Comparable-Interface sowie das Comparable-Interface der Java Collections API und können damit eigene Datentypen erstellen
* Sie können Sortieralgorithmen mit dem Comparable-Interface umsetzen
* Sie können Sortieralgorithmen mit dem Comparator-Interface umsetzen

</textarea>
</section>

<section data-markdown>
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Lektion 13 - Fragen zu List-Interface, Sortieralgorithmen?
=============================

Sind noch Fragen zu:

* List-Interface (ArrayList etc.)?
* Sortieralgorithmen? Konnten Sie mind. 1 der Algorithmen erfolgreich in Java umsetzen?
</textarea>
</section>

<section data-markdown>
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Sortieren von komplexen Datentypen
=============================

Bis jetzt haben wir simple Zahlen-Arrays sortiert:

```java
int[] a = {1,8,5,3,9,4};
bubbleSort(a);
```

Sortier-Algorithmen basieren auf Vergleichen (z.B. `a < b`). Bei einem Zahlen-Array ist immer klar, was "kleiner als" bedeutet. Diese Beispiele waren auch relativ "akademisch".

**Real Life**

Ein konkretes Problem könnte jedoch so aussehen: Sie haben eine Liste von Personen-Daten (Name, Vorname, Geburtsdatum, Strasse, PLZ, Ort), und möchten diese nach
Name, später ev. nach Geburtsdatum sortieren:

```java
// Unser Person-Datentyp:
public class Person {
	public String name;
	public String vorname;
	public Date geburtstag;
	// ....

	public Person(String name, String vorname, Date geburtstag) {
		this.name = name;
		this.vorname = vorname;
		this.geburtstag = geburtstag;
	}
}

// Das Hauptprogramm:
public class Main {
	public static void main(String[] args) {
		Person[] personen = {
				new Person("Vader", "Darth", new Date(1979, 2, 30)),
				new Person("Skywalker", "Luke", new Date(1983, 7, 21)),
				new Person("Solo", "Han", new Date(1976, 10, 1))
		};

		// Sortieren nach Name, oder Geburtsdatum
        bubbleSort(personen);
	}
}
```

<i class="far fa-hand-point-right"></i> Was bedeutet nun "grösser als", resp. "kleiner als"?<br />
<i class="far fa-hand-point-right"></i> Müssen Sie nun für jede mögliche Sortiervariante (nach Name, nach Geburtsdatum ....) Ihren Sortier-Algorithmus anpassen?<br />
<i class="far fa-hand-point-right"></i> Wir müssen also einen Weg finden:
* um den Vergleich "grössser als" / "kleiner als" generisch (für verschiedene Fälle) zu lösen
* um den Sortieralgorithmus selber so umzubauen, dass er für verschiedene Datentypen funktioniert.

</textarea>
</section>

<section data-markdown>
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Sortieren von komplexen Datentypen - Comparable
=============================

Java hilft uns hier wiederum mit der Collections API. Java stellt dazu zwei Interfaces zur Verfügung:

* Interface `Comparable`: Macht Objekte "Vergleichbar" mit anderen Objekten <br />(https://docs.oracle.com/javase/7/docs/api/java/lang/Comparable.html)
* Interface `Comparator`: Definiert eine Vergleichsfunktion für Sortieralgorithmen<br /> (https://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html)


** Comparable-Interface **

Das `Comparable`-Interface macht nun Objekte "vergleichbar": Es definiert eine Funktion, welche die Frage "Ist A &lt; B?" beantwortet.

Sie kennen das Comparable-Interface bereits von der String-Klasse:

```java
String a = "Alex";
String b = "Lukas";
int resultat = a.compareTo(b); // --> resultat ist < 0 (a < b), 0 (a == b), > 0 (a > b), in dem Fall -11 (lexikalische Distanz)
```

String.compareTo entscheidet dies anhand der "lexikalischen Ordnung" der Buchstaben.

**Beispiel-Implementation**

```java
// Die Klasse Person implementiert das Comparable-Interface für Person-Objekte:
public class Person implements Comparable<Person> {
	// ....

	// Konkrete Implementation von compareTo:
    // Hier wird aufgrund des Namens entschieden, welche Person "kleiner" ist:
	public int compareTo(Person o) {
		return this.name.compareTo(o.name);
	}
}
```

Unser Sortier-Algorithmus kann dies nun verwenden: Person implementiert nun das Comparable-Interface, somit können wir anstatt `a < b` nun `compareTo()` verwenden:

```java
public void bubbleSort(Comparable[] arr) {
    // ..... mach was ....
    if (arr[i].compareTo(arr[i+1]) >= 0) {
        // tauschen ...
    }
    // ..... mach noch was ......
}
```

Je nach Implementation von `compareTo()` werden die Objekte nun entpsrechend sortiert! Unser bubbleSort ist somit sogar Typ-unabhängig, solange der Typ Comparable implementiert!

</textarea>
</section>

<section data-markdown>
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Sortieren von komplexen Datentypen - Comparator
=============================


** Comparator-Interface **

Mit dem `Comparable`-Interface können wir nun zwar Objekte auf definierte Weise miteinander vergleichen, aber eben nur auf EINE Weise:
Wenn wir unsere Personen später nach Geburtsdatum sortieren wollen, stehen wir bereits an: compareTo vergleicht in unserem Fall den Namen.

Hier hilft uns das **Comparator**-Interface: Es liefert das Interface für eine Vergleichsfunktion, welche unabhängig vom "Ziel-Objekt" implementiert werden kann.
Viele vorgefertigte Sortier-Funktionen der Collections-API nehmen neben der Liste auch ein Comparator-Objekt mit entgegen (Collections.sort, Arrays.sort).

** Anwendung **

Schritt 1: Sie definieren eine (oder mehrere) Klassen, welche Comparator implementieren:

```java
// Name-Vergleich:
// Um möglichst generisch zu bleiben, nehmen wir hier "Object" als Typ entgegen (Person ist auch ein Object), und prüfen
// mittels Typ-Prüfung, ob wir tatsächlich ein Person-Objekt erhalten: Dann sortieren wir à la Person, ansonsten nicht:
public class PersonByNameComparator implements Comparator<Object> {
	public int compare(Object o1, Object o2) {
		if (o1 instanceof Person && o2 instanceof Person) {
			Person p1 = (Person)o1;
			Person p2 = (Person)o2;
			return p1.name.compareTo(p2.name);
		} else {
			return -1;
		}
	}
}

// Geburtstags-Vergleich, analog Name-Vergleich, siehe oben
public class PersonByGeburtstagComparator implements Comparator<Object> {
	public int compare(Object o1, Object o2) {
		if (o1 instanceof Person && o2 instanceof Person) {
			Person p1 = (Person)o1;
			Person p2 = (Person)o2;
			return p1.geburtstag.compareTo(p2.geburtstag);
		} else {
			return -1;
		}
	}
}
```
</textarea>
</section>

<section data-markdown>
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Sortieren von komplexen Datentypen - Comparator
===================

Schritt 2: Bauen Sie Ihre Sortier-Funktion um, sodass sie ein Comparator-Objekt als Parameter aufnimmt:

```java
public void bubbleSort(Object[] arr, Comparator<Object> cmp) {
    // ..... mach was ....
    if (cmp.compare(arr[i], arr[i+1]) >= 0) {
        // tauschen ...
    }
    // ..... mach noch was ......
	}
```

Schritt 3: So können Sie Ihren Array nun wahlweise nach name oder Geburtstag sortieren:
```java
public class Main {
	public static void main(String[] args) {
		Person[] personen = {
				new Person("Vader", "Darth", new Date(1979, 2, 30)),
				new Person("Skywalker", "Luke", new Date(1983, 7, 21)),
				new Person("Solo", "Han", new Date(1976, 10, 1))
		};

		// nach Name sortieren:
		bubbleSort(personen, new PersonByNameComparator());
		// nach Geburtstag sortieren:
		bubbleSort(personen, new PersonByGeburtstagComparator());
	}
}
```


</textarea>
</section>

<section data-markdown>
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Aufgaben
======================

Aufgabe 1
------------

* Implementieren Sie die Person-Klasse.
* Nehmen Sie Ihre Implementation von BubbleSort und/oder Selection Sort. Bauen Sie diese um, sodass Sie:
    * Ihrer Sortier-Funktion nun einen Array von Person-Objekten übergeben können (`Person[] arr`)
    * Ihre Sortier-Funktion das comparable-Interface von Person für den Vergleich benutzt
* Testen Sie die Funktion in einem Hauptprogramm: Geben Sie jeweils das Anfangs- und das End-Array aus!

Aufgabe 2
------------

* Bauen Sie die `compareTo()`-Funktion in Person so um, dass die Sortierung rückwärts (Z-A) erfolgt!
* Testen Sie die Funktion in einem Hauptprogramm: Geben Sie jeweils das Anfangs- und das End-Array aus!
* Bauen Sie Ihren Sortieralgorithmus so um, dass Sie WAHLWEISE vorwärts oder rückwärts sortieren können! Sie können die Richtung z.B. als Parameter übergeben:
  `void bubbleSort(Person[] personen, boolean vorwaerts = true);`


Aufgabe 3
------------

* Sorgen Sie in der `compareTo()`-Funktion dafür, dass Ihre Person-Objekte erst nach Name, DANN nach Vorname sortiert wird! (also Daten mit denselben Namen sollen auch nach Vorname richtig sortiert sein)
* Beispiel:
```
Eingabe-Array: [
    {name: 'Maler', vorname: 'Chef'},
    {name: 'Meier', vorname: 'Max'},
    {name: 'Maler', vorname: 'Meister'},
    {name: 'Meier', vorname: 'Arnold'},
    {name: 'Maler', vorname: 'Lehrling'}
    ]
Ausgabe-Array: [
    {name: 'Maler', vorname: 'Chef'},
    {name: 'Maler', vorname: 'Lehrling'
    {name: 'Maler', vorname: 'Meister'},
    {name: 'Meier', vorname: 'Arnold'},
    {name: 'Meier', vorname: 'Max'}
    ]
```
* Testen Sie die Funktion in einem Hauptprogramm: Geben Sie jeweils das Anfangs- und das End-Array aus!


</textarea>
</section>
 {% endblock %}
