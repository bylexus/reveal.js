{% extends "../_base_template.html" %}
{% block title %}Lektion 7 - Laufzeitanalyse{% endblock %}

{% block sections %}
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Lektion 7 - Laufzeitanalyse
=============================

Ziele:

* Sie können die O-Notation, den Sinn und Zweck in eigenen Worten beschreiben
* Sie kennen die wichtigsten Komplexitätsklassen
* Sie können Algorithmen in ihrer Komplexität richtig bewerten.

</textarea>
</section>


<section>
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Lektion 9 - Laufzeitanalyse
=============================

Schauen Sie sich folgenden Algorithmus an:

```java
int find(int[] array, int wert) {
    for (int i = 0; i < array.length; i++) {
        if (array[i] == wert) {
            return i;
        }
    }
    return -1;
}
```

* Was macht dieser Algorithmus?
* Ist dieser Algorithmus effizient?
* Wie bewerten Sie die "Effizienz" eines Algorithmus? Welche Kriterien schauen Sie da an?

<i class="far fa-hand-point-right"></i> Padlet dazu: https://padlet.com/alex_schenkel/eq5znlge1ams

</textarea>
</section>
</section>

<section>
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Effizienz-Parameter
=============================

Für die Effizienz eines Algorithmus sind 3 Parameter relevant:

* **Rechenzeit**: Anzahl der durchgeführten Elementaroperationen in Abhängigkeit von der Eingabegrösse
* **Speicherplatz**: Maximale Speicherverbrauch während der Ausführung des Algorithmus in Abhängigkeit von der Komplexität der Eingabe
* **Bandbreite**: Wie gross ist die erforderliche Datenübertragung

Wir betrachten bei der Effizienzanalyse ausschliesslich die **Entwicklung des Aufwandes in Abhängigkeit der Eingabegrösse**.

Auf unser Beispiel von vorhin gemünzt (übrigens das Suchen eines Wertes in einem Array):

* Wieviele Rechenschritte benötigt unser Algorithmus?
* Wie "mühsam" sind die einzelnen Rechenschritte (Komplexitätsanalyse)?
* Wie verhält sich die Anzahl Rechenschritte zur Eingeabegrösse (in unserem Beispiel: obere Grenze)?

<i class="far fa-hand-point-right"></i>Komplexität: Wir suchen also eine **mathematische Funktion, welche die Komplexität in Abhängigkeit der Eingabegrösse darstellt.**

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Effizienz-Parameter
=============================

<i class="far fa-hand-point-right"></i>Komplexität: Wir suchen also eine **mathematische Funktion, welche die Komplexität in Abhängigkeit der Eingabegrösse darstellt.**

<div style="display: flex">
    <img src="komplexitaet_arraysuche.png" width="60%"/>
    <div style="margin-left: 10px">
        Beispiel: `n = 100`<br />
        <ul>
            <li>Eingangsgrösse `n`: Array-Elemente</li>
            <li>`n = 100` (Array mit 100 Elementen)</li>
            <li><i class="far fa-hand-point-right"></i> `f(n) = n`: <br />Wir benötigen also auch 100 "Schritte"</li>
            <li><i class="far fa-hand-point-right"></i> Der Algorithmus verhält sich also **linear / proportional** zur Eingangsgrösse</li>
        </ul>

    </div>
</div>
</textarea>
</section>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Praktisches Beispiel: Heuballen
=============================

**Praktisches Beispiel**: Sie müssen einem befreundeten Landwirt helfen, seine Heuballen vom Lastwagen in die Scheune zu tragen. Wie lange dauert dies?

* **Eingabegrösse**: Anzahl Heuballen
* **Anzahl Rechenschritte**: Was muss ich mit einem einzelnen Heuballen machen, bis er in der Scheune ist? (Abladen, Treppe rauftragen, ...)

--> Komplexitätsanalyse: Wie aufwändig sind die einzelnen Schritte, also das Einbringen eines Heuballens?

* Eingabegrösse: Charakterisierung unserer Daten: Welche "Eingabegrösse" ist relevant für unseren Algorithmus?
* Berechnungsschritte: Bestimmen der abstrakten Operationen pro Eingabe / pro Durchlauf

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Praktisches Beispiel: Heuballen
=============================

Spielen wie dies für die Heuballen durch!

* Unser Wagen hat 120 Heuballen geladen
* Wir brauchen folgende Schritte:
  * Abladen
  * zur Scheune laufen
  * freien Platz suchen
  * Ballen platzieren

<i class="far fa-hand-point-right"></i> Wir benötigen also **4 Einzelschritte** pro Heuballen, also total **4 * 120 Schritte**.

Wir können dies auch in Abhängigkeit der Eingabegrösse schreiben:

**Komplexität `T => T(4*n)`**

<i class="far fa-hand-point-right"></i> Wir haben somit eine mathematische Funktion definiert, welche uns in Abhängigkeit der Eingabegrösse die Komplexität berechnet.
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Komplexitätsanalyse - Grundsätzliches
=============================

Auf Algorithmen bezogen bedeutet dies folgendes:

* **Eingabegrösse**: Anzahl Bytes, Anzahl Objekte, Anzahl Stellen ...
* **Berechnungsschritte**: Speicherzugriffe, Berechnungsschritte, Funktionsaufrufe ...
* **Komplexitätsanalyse**: Mathematische Analyse.

<i class="far fa-hand-point-right"></i> Bei der Komplexitätsanalyse gehen wir immer vom **Worst Case** aus!

Was bedeutet dies?

**Beispiel: Finden eines Wertes in einem Array:**

```java
int find(int[] array, int wert) {
    for (int i = 0; i < array.length; i++) {
        if (array[i] == wert) {
            return i;
        }
    }
    return -1;
}
```

* Wieviel Mal durchlaufen wir die Schlaufe...
  * im **BESTEN** Fall? (1 mal)
  * im **SCHLECHTESTEN** Fall? (n mal)

<i class="far fa-hand-point-right"></i> Wir müssen für die Analyse davon ausgehen, dass der **schlechteste** Fall eintritt.

Die Berechnung eines "durchschnittlichen" Wertes ist sehr, sehr schwierig, und kommt immer auch auf die Eingabedaten an.
Für die Komplexitätsanalyse verwenden wir daher nur den schlechtesten Fall: Damit muss gerechnet werden.

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Komplexitätsanalyse - Beispiel
=============================

Spielen wir das Beispiel vom Anfang durch:

```java
int find(int[] array, int wert) {
    for (int i = 0; i < array.length; i++) {
        if (array[i] == wert) {
            return i;
        }
    }
    return -1;
}
```

* Was ist unsere **Eingabegrösse**? <span class="fragment"> --> `int n`: Je höher "n", desto mehr Schritte sind nötig</span>
* Wieviele **Berechnungsschritte** werden benötigt?
  * <!-- .element class="fragment" --> 1x Summe initialisieren
  * <!-- .element class="fragment" --> 1x i initialisieren
  * <!-- .element class="fragment" --> n mal i mit Grenze vergleichen
  * <!-- .element class="fragment" --> n mal Summe aufaddieren
  * <!-- .element class="fragment" --> n mal i erhöhen

--> Wir erhalten also folgende Funktion in Abhängigkeit von "n":

<!-- .element class="fragment" --> T(n): 1 + 1 + n + n + n = 3n + 2

<!-- .element class="fragment" --> <i class="far fa-hand-point-right"></i>Dieser Algorithmus hat also eine lineare (proportionale) Abhängigkeit zu seiner Eingabegrösse.

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Komplexitätsanalyse - Beispiel 2
=============================

Ein zweites Beispiel:

```java
// wieviele doppelte Elemente gibt es im Array? Naiver Ansatz:
public int doubleElements(int[] a) {
    int count = 0;
    for (int i = 0; i <= a.length; i++) {
        for (int j = 0; j < a.length; j++) {
            if (i != j && a[i] == a[j]) {
                count++;
            }
        }
    }
    return count;
}
```

* Was ist unsere **Eingabegrösse**? <span class="fragment">--> Länge von a = n</span>
* Wieviele **Berechnungsschritte** werden benötigt?
  * <!-- .element class="fragment" --> 1x i initialisieren
  * <!-- .element class="fragment" --> 1x j initialisieren
  * <!-- .element class="fragment" --> n mal i mit Länge von a vergleichen
  * <!-- .element class="fragment" --> n * n mal j mit Länge von a vergleichen
  * <!-- .element class="fragment" --> n * n mal Werte vergleichen (i,j), auslesen und vergleichen, hochzählen (4 Schritte)

--> Wir erhalten also folgende Funktion in Abhängigkeit von "n":

<!-- .element class="fragment" --> T(n): 1 + 1 + n + n<sup>2</sup> + 4*n<sup>2</sup> = 5n<sup>2</sup> + n + 2

<!-- .element class="fragment" --> <i class="far fa-hand-point-right"></i>Dieser (zugegeben naive) Algorithmus hat also eine **quadratische** Abhängigkeit zu seiner Eingabegrösse.

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> O-Notation (Θ)
=============================

Für die Effizienzanalyse von Algorithmen wird eine spezielle mathematische Notation verwendet,
die als **O-Notation** bezeichnet wird. Die O-Notation erlaubt es, Algorithmen auf einer höheren Abstraktionsebene
miteinander zu vergleichen.

Algorithmen können mit Hilfe der O-Notation unabhängig von Implementierungsdetails,
wie Programmiersprache, Compiler und Hardware-Eigenschaften, verglichen werden.

**Die O-Notation ist ein Mass dafür, wie sich der Aufwand verhält, wenn man mehr Daten bearbeitet. Wenn z.B. ein Sortieralgorithmus
eine Komplexität von O(n<sup>2</sup>) aufweist, hat er 2'500 mal länger für 1000 Datensätze als für 20 Datensätze.**

> Bei der O-Notation wird die asymptotischen oberen Schranke für die Aufwandsfunktion angegeben.
In anderen Worten: Wir stellen mit der O-Notation immer das **Worst-Case-Szenario** dar.
Die O-Notation zeigt nur die Effizient-**Klasse**, also die Tendenz, wie sich ein Algorithmus zur
Eingabegrösse verhält. Deshalb werden Koeffizienten und nicht dominante Terme weggelassen.

<div style="display: flex">
    <img src="bigo.png" width="40%" />
    <div style="margin-left:10px">aus T( 3n+2 ) wird somit: Θ(n)</div>
</div>

</textarea>
</section>

<section>
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> O-Notation - Rechenregeln
=============================

Verständliches Beispiel:

> Wenn Sie eine Funktion $g(n)\,=\,n^3\,+\,2\,*\,n^2$ betrachten, so ist der Term $n^3$ in dieser Funktion dominant
gegenüber dem Term $2∗n^2$. Das kann man mathematisch beweisen, aber lassen wir das.
Wir ignorieren also den Term $2∗n^2$ und schreiben:
Die Komplexität dieser Funktion ist $n^3=O(n)$.
<br /><strong>Beachten Sie: Das Gleichheitszeichen ist nicht als “mathematisches Gleich” zu interpretieren.</strong>
Es geht um Mengen, die Darstellung $n^3\,\in\,O(n)$ wäre eigentlich besser, aber weniger verbreitet.

Aus diesem Beispiel folgen ein paar **“Rechenregeln”**: (nächste Folie)

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> O-Notation - Rechenregeln
=============================

**Addition**

1. $f(n)\,=\,n\,+\,3\,\Longrightarrow\,f(n)\,=\,Θ(n)$: Konstante Summanden werden vernachlässigt
2. $f(n)\,=\,n^2\,+\,3n\,\Longrightarrow\,f(n)\,=\,Θ(n^2)$: Es zählt der Summand mit dem stärkeren Wachstum

**Multiplikation**

1. $f(n)\,=\,3n\,\Longrightarrow\,f(n)\,=\,Θ(n)$: Konstante Faktoren werden vernachlässigt
2. $f(n)\,=\,n^2\,*\,3n\,\Longrightarrow\,f(n)\,=\,Θ(n^3)$: Es zählt die Summe der Exponenten

Wir können somit auch mit Thermen der O-Notation rechnen:

$O(1) + O(n^2) + O(n) = O(1 + n^2 + n) = O(n^2)$

</textarea>
</section>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> O-Notation - Komplexitätsklassen
=============================

Es gibt eine Reihe von Standard-Komplexitätsklassen - hier eine Liste in aufsteigender Reihenfolge der:
Komplexitätsentwicklung:

| Klasse | Beschreibung |
|------|--------------|
| $O(1)$ |  der konstante Aufwand (einige Suchverfahren für Hashtabellen, Array-Index-Zugriff) |
| $O(log(n))$ |  der logarithmische Aufwand (allgemeine Suchverfahren für Tabellen (Baum-Suchverfahren) |
| $O(n)$ |  der lineare Aufwand (für sequenzielle Suche, Suche in Texten, syntaktische Analyse von Programmen) |
| $O(n*log(n))$ |  (Sortieren) |
| $O(n2)$ |  der quadratische Aufwand (einige dynamische Optimierungsverfahren (z.B. optimale Suchbäume), Multiplikation Matrix-Vektor) |
| $O(n^k)\,fuer\,k\,\ge\,0$ |  der polynomiale Aufwand (Verschiedene, zum Beispiel Matrizen Multiplikationen) |
| $O(2^n)$ |  der exponentielle Aufwand (viele Optimierungsprobleme ) |
</textarea>
</section>


<section>
<section data-markdown >
<textarea data-template>
<i class="fas fa-flask"></i> O-Notation - Praxis
=============================

Beispiel 1: Sequenz von Befehlen
-----------------------------------

```java
public int inkrement(int n) {
  int x = 0;
  x = n + 1;
  return x;
}
```
<strong>$f(n) = O(???)$</strong>
</textarea>
</section>
<section data-markdown >
<textarea data-template>
<i class="fas fa-flask"></i> O-Notation - Praxis
=============================

Beispiel 1: Sequenz von Befehlen
-----------------------------------

```java
public int inkrement(int n) {
  int x = 0;    // O(1)
  x = n + 1;    // O(1)
  return x;     // O(1)
}
```
**$O(f(n)) = O(1) + O(1) + O(1) = 3\*O(1) = O(3\*1)$**
</textarea>
</section>
<section data-markdown >
<textarea data-template>
<i class="fas fa-flask"></i> O-Notation - Praxis
=============================

Beispiel 1: Sequenz von Befehlen
-----------------------------------

```java
public int inkrement(int n) {
  int x = 0;    // O(1)
  x = n + 1;    // O(1)
  return x;     // O(1)
}
```
**$O(f(n)) = O(1) + O(1) + O(1) = 3\*O(1) = O(3\*1)$**

Somit (nach Anwendung unserer Rechenregeln): <strong>$O(f(n)) = O(1)$</strong>

<i class="far fa-hand-point-right"></i> Koeffizienten werden weggelassen: aus 3*1 wird 1!

<i class="far fa-hand-point-right"></i> KONSTANTE Komplexität!
</textarea>
</section>
</section>




<section>
<section data-markdown>
<textarea data-template>
<i class="fas fa-flask"></i> O-Notation - Praxis
=============================

Beispiel 2: Schleifen
-----------------------------------

```java
public int berechne(int n) {
  int x = 0;
  for (int i=0; i < n; i++) {
    x = x + 1;
  }
  return x;
}
```
<strong>$f(n) = O(???)$</strong>
</textarea>
</section>
<section data-markdown>
<textarea data-template>
<i class="fas fa-flask"></i> O-Notation - Praxis
=============================

Beispiel 2: Schleifen
-----------------------------------

```java
public int berechne(int n) {
  int x = 0;                      // O(1)
  for (int i=0; i < n; i++) {     // i=0: O(1), i<n: n*O(1), i++: n*O(1)
    x = x + 1;                    // n*O(1)
  }
  return x;                       // vernachlässigen wir schon... wir wissen: O(1) + O(1) = O(1)
}
```

<strong>$O(f(n)) = O(1) + O(1) + n\*O(1) + n\*O(1) + n\*O(1) = 2\*O(1) + 3\*O(n) = O(3\*n + 2)$</strong>
</textarea>
</section>
<section data-markdown>
<textarea data-template>
<i class="fas fa-flask"></i> O-Notation - Praxis
=============================

Beispiel 2: Schleifen
-----------------------------------

```java
public int berechne(int n) {
  int x = 0;                      // O(1)
  for (int i=0; i < n; i++) {     // i=0: O(1), i<n: n*O(1), i++: n*O(1)
    x = x + 1;                    // n*O(1)
  }
  return x;                       // vernachlässigen wir schon... wir wissen: O(1) + O(1) = O(1)
}
```
<strong>$O(f(n)) = O(1) + O(1) + n\*O(1) + n\*O(1) + n\*O(1) = 2\*O(1) + 3\*O(n) = O(3\*n + 2)$</strong>

Somit (nach Anwendung unserer Rechenregeln): <strong>$O(f(n)) = O(n)$</strong>

<i class="far fa-hand-point-right"></i> LINEARE Komplexität!
</textarea>
</section>
</section>












<section>
<section data-markdown>
<textarea data-template>
<i class="fas fa-flask"></i> O-Notation - Praxis
=============================

Beispiel 3: Hmm... Was ist das?
-----------------------------------

```java
public int berechne(int n) {
  int x = 0;
  for (int i=0; i < 5; i++) {
    x = x + 1;
  }
  return x;
}
```
<strong>$O(f(n)) = O(1) + O(1) + 5\*O(1) + 5\*O(1) + 5\*O(1) = 17\*O(1)$</strong>
</textarea>
</section>
<section data-markdown>
<textarea data-template>
<i class="fas fa-flask"></i> O-Notation - Praxis
=============================

Beispiel 3: Hmm... Was ist das?
-----------------------------------

```java
public int berechne(int n) {
  int x = 0;                     // O(1)
  for (int i=0; i < 5; i++) {    // i=0: O(1), i<5: 5*O(1), i++: 5*O(1)
    x = x + 1;
  }
  return x;
}
```
<strong>$O(f(n)) = O(1) + O(1) + 5\*O(1) + 5\*O(1) + 5\*O(1) = 17\*O(1)$</strong>

Somit (nach Anwendung unserer Rechenregeln): <strong>$O(f(n)) = O(1)$</strong>

<i class="far fa-hand-point-right"></i> KONSTANTE Komplexität, trotz Schlaufe!
</textarea>
</section>
</section>








<section>
<section data-markdown>
<textarea data-template>
<i class="fas fa-flask"></i> O-Notation - Praxis
=============================

Beispiel 4: Hmm... Nochmals Was ist das?
-----------------------------------

```java
public int berechne(int n) {
  int x = 0;
  for (int i=0; i < n; i = 2*i) {
    x = x + 1;
  }
  return x;
}
```
</textarea>
</section>
<section data-markdown>
<textarea data-template>
<i class="fas fa-flask"></i> O-Notation - Praxis
=============================

Beispiel 4: Hmm... Nochmals Was ist das?
-----------------------------------

```java
public int berechne(int n) {
  int x = 0;
  for (int i=1; i < n; i = 2*i) {
    x = x + 1;
  }
  return x;
}
```
<strong>$O(f(n)) = O(1) + O(1) + \log_2(n)\times{O(1)} + \log_2(n)\times{O(1)} + \log_2(n)\times{O(1)} = O(3*\log_2(n) + 2)$</strong>

Somit (nach Anwendung unserer Rechenregeln): <strong>$O(f(n)) = O(log_2(n))$</strong>

<i class="far fa-hand-point-right"></i> LOGARITHMISCHE Komplexität: Die Anzahl Rechenschritte erhöht sich mit einer logarithmischen Funktion in Abhängigkeit von $n$
</textarea>
</section>
</section>


<section>
<section data-markdown>
<textarea data-template>
<i class="fas fa-flask"></i> O-Notation - Praxis
=============================

Weitere Übungen
----------------

Weitere Übungen / Hausaufgaben finden Sie auf Moodle.
</textarea>
</section>
</section>
{% endblock %}
