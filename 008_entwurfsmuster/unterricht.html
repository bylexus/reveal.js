{% extends "../_base_template.html" %}
{% block title %}Lektion 8 - Entwurfsmuster, Iteration, Rekursion{% endblock %}

{% block sections %}
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Hausaufgaben von letztem Mal
=============================

Aufgaben zur Effizienzanalyse - O-Notation

Fragen?

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Lektion 8 - Entwurfsmuster, Iteration, Rekursion
=============================

Ziele:

* Sie können ein paar Beispiele von Entwurfsmuster nennen
* Sie verstehen den Verwendungszweck von Entwurfsmustern
* Sie können an bestehendem Source-Code Entwurfsmuster erkennen
* Sie können die rekursive Programmform beschreiben und ihren Nutzen (und Probleme) benennen
* Sie können rekursive und iterative Programmformen unterscheiden
* Sie können einfache, definierte Probleme in rekursiver Form umsetzen
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Entwurfsmuster
=============================

Unter **Entwufsmuster** versteht man Herangehensweisen, wie Algorithmen aus Anforderungsbeschreibungen gelöst werden können.

Der Algorithmenentwurf ist eine **kreative Tätigkeit**, die durch Muster ( **best practices**) unterstützt wird.

Der Entwurf von Algorithmen erfolgt nach dem Prinzip der schrittweisen Verfeinerung von Pseudo Code-Algorithmen.
Pseudo Code-Teile werden im ersten Schritt durch verfeinerten Pseudo Code ersetzt und im nächsten Schritt durch Programmiersprachen Code.

Beispiel:

Beispiel:
Der Schritt:

1. Pellkartoffeln kochen

wird verfeinert zu:

1.1 Fülle Topf mit Kartoffeln<br />
1.2 Füge Wasser dazu<br />
1.3 Stelle topf auf Herdplatte<br />
1.4 Stelle Drehknopf auf 7<br />
1.5 Koche das Wasser

... und erst danach wagen wir uns an den Code.
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Entwurfsmuster
=============================

Wir sehen uns folgende **Entwufsmuster** etwas genauer an:

* **Greedy**: wir suchen maximale oder optimale Lösungen
* **Divide and conquer**: Wir teilen ein grosses Problem in kleinere (und immer kleinere) Teilprobleme
* **Backtracking**: Wir versuchen eine Lösung, und wenn die nicht geht, gehen wir zurück und versuchen einen anderen Weg

Diese Entwurfsmuster sind **keine fertigen Rezepte**, sondern nur Ideen, wie bestimmte Probleme angegangen werden können.

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Entwurfsmuster - Greedy
=============================

Idee
------

Greedy bedeutet "Gierig": Wir wollen mit diesem Algorithmus in jedem Teilschritt möglichst viel erreichen.

**Beispiel Münz-Rückgabe:**

* Sie müssen einen Rückgeld-Algoritmus entwerfen.
* Sie möchten mit möglichst wenig Münzen auf den Betrag kommen.
* Sie haben folgende Münzen: 5rp, 10rp, 50rp, 1Fr., 2Fr. 5Fr
* Sie müssen 13.75 rückgeben.

"Greedy" bedeutet hier: Wir versuchen, in jedem Teilschritt möglichst viel "zurückzugeben", bis der Betrag erreicht ist:

23.75 = 5Fr + 5Fr + 2Fr + 1Fr + 50rp + 20rp + 5rp

Das scheint optimal! Hier ist das lokale Optimum (Optimum in einem Schritt) auch das globale Optimum (optimales Endergebnis).

**Gegenbeispiel**

* Selbe Aufgabe, aber Sie haben nun folgende Münzen: 1rp, 5rp, 11rp.
* Geben Sie 15rp zurück!

15rp = 11rp + 1rp + 1rp + 1rp + 1rp

<i class="far fa-hand-point-right"></i> Hier erreicht man durch Greedy und lokale Optimierung kein globales Optimum (5rp + 5rp + 5rp wäre besser!)
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Entwurfsmuster - Greedy
=============================

Wann kann Greedy sinnvoll sein?

1. Gegebene Menge von Inputwerten (hier: Münzen)
2. Menge von Lösungen, die aus Eingabewerten aufgebaut sind
3. Lösungen lassen sich schrittweise aus partiellen Lösungen, beginnend bei der leeren Lösung, durch Hinzunahme von Eingabewerten aufbauen.
   <br />Alternativ: Bei einer ganzen Menge beginnend schrittweise jeweils ein Element entfernen
4. Bewertungsfunktion existiert für partielle und vollständige Lösung (was ist gut / schlecht)
5. Gesucht wird die / eine **optimale / maximale Lösung**

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Entwurfsmuster - Divide and Conquer
=============================

"Teile und Herrsche" ist ein sehr wichtiges Prinzip um Probleme zu lösen - nicht nur in Algorithmen!
Es besagt grundsätzlich, dass **ein grosses Problem in kleine Teilprobleme** aufgeteilt wird, welche in sich
einfacher zu lösen sind.

Grundidee
------------

> Teile das gegebene Problem in mehrere getrennte Teilprobleme auf, löse diese einzeln und setze die Lösungen des
ursprünglichen Problems aus den Teillösungen zusammen. Wende dieselbe Technik auf jedes der Teilprobleme an, dann auf
deren Teilprobleme, usw, bis die Teilprobleme klein genug sind, dass man eine Lösung explizit angeben kann. Strebe an,
dass jedes Teilproblem von derselben Art ist wie das ursprüngliche Problem, so dass es mit demselben Algorithmus gelöst
werden kann.


** Beispiel Mergesort**

(werden wir auch noch kennen lernen)

```
funktion mergesort(liste);
  falls (Größe von liste <= 1) dann antworte liste
  sonst
     halbiere die liste in linkeListe, rechteListe
     linkeListe = mergesort(linkeListe)
     rechteListe = mergesort(rechteListe)
     antworte merge(linkeListe, rechteListe) // Zusammenführen der Teilergebnisse im "Reissverschlussverfahren"
```

Siehe Wikipedia: https://de.wikipedia.org/wiki/Mergesort#Implementierung
</textarea>
</section>

<section>
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Entwurfsmuster - Backtracking
=============================

Die Idee des Backtracking ist das **Versuchs-und-Irrtum-Prinzip** (trial and error).
Versuche, die erreichte Teillösung schrittweise zu einer Gesamtlösung auszubauen.
Falls die Teillösung nicht zu einer Lösung führen kann, dann nimm den letzten Schritt bzw.
die letzten Schritte zurück und probiere stattdessen alternative Wege.

Alle in Frage kommenden Lösungswege werden ausprobiert.
Vorhandene Lösung wird entweder gefunden (unter Umständen nach sehr langer Laufzeit)
oder es existiert definitiv keine Lösung.
Backtracking (“Zurückverfolgen“) ist eine allgemeine systematische Suchtechnik.

**Beispiel : Labyrinth Suche**

Folgendes Labyrinth soll systematisch durchsucht werden (Startpunkt M / Ziel K).
Daraus entsteht der Suchbaum (jeweils mit den Koordinaten des Labyrinths).

<img src="labyrinth.png" />
<img src="backtrackbaum.png" />

</textarea>
</section>
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Entwurfsmuster - Backtracking
=============================

**Einsatzfelder**

Zu den typischen Einsatzfeldern von Backtracking gehören zum Beispiel einige Spielprogramme (Schach, Dame, Labyrinthsuche,…).
Aber auch die Erfüllbarkeit von logischen Aussagen wie logische Programmiersprachen, Optimierung von Gattern oder Model checking (Theorembeweiser).

Ein weiteres Einsatzfeld sind Planungsprobleme und Konfigurationen wie logistische Fragestellungen
(Traveling Salesman, der kürzeste Wege, die optimale Verteilung, das Färben von Landkarten oder auch nichtdeterministisch-lösbare Probleme.

</textarea>
</section>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Gemeinsame Übung
=============================

Wir sollen nun gemeinsam den **Pseudo-Code für das Münzproblem** erarbeiten: Dies ist ein Greedy-Algorithmus:

**Anforderung:**

Den gegebenen Betrag `B` soll der Algoritmus in vorhandene Münzen aufteilen, und zwar in möglichst kleine.
Der Algoritmus liefert eine Liste `L` mit den Münzen.

Es stehen folgende Münzen zur Verfügung:

5Rp, 10Rp, 20Rp, 50Rp, 1Fr, 2Fr, 5Fr.

Wir entwickeln gemeinsam den Pseudo-Code für diesen Algorithmus. Danach setzen Sie ihn in Programmcode um (Java).

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Übungen
=============================

Sie finden folgende Aufgaben auf Moodle. Lösen Sie diese (jetzt und als Hausaufgabe über die Ferien):

* Greedy: Münzbeispiel (Münz-Ausgabe an Billetschalter)
* Greedy: Regale anordnen
* Divide-and-Conquer: Binary Search
* Greedy: Überleben auf einer Insel
* Greedy: Ägyptische Bruchrechnung

</textarea>
</section>

{% endblock %}
