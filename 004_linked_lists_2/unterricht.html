{% extends "../_base_template.html" %}
{% block title %}Lektion 4 - Linked Lists{% endblock %}

{% block sections %}
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Lektion 4 - Linked Lists
=============================

Ziel der Lektion:

* Sie verstehen den Aufbau einer Linked List
* Sie können eine Linked List in Java selber programmieren
* Sie können gängige Operationen / Methoden von LinkedLists implementieren
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Hausaufgaben - Implementation der List-Methoden
=============================

* Wir schauen uns die Implementationen der List-Funktionen an:

* **`append()`**
* **`printList()`**
* **`insert()`**
* **`remove()`**
* **`move()`**

</textarea>
</section>

<section>
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Intermezzo - Vergleich mit Array-Operationen
=============================

Rufen sie sich nochmals die folgenden Funktionen ins Gedächtnis:

* `append()`
* `insert()`
* `remove()`

Fragen:
* Können Sie diese ohne Weiteres mit Arrays implementieren?
* Wo liegt der grosse Unterschied zu Listen, wenn Sie diese Methoden mit Arrays implementieren müssen?
* Wie gross ist der rechnerische Aufwand in den beiden Datenstrukturen, um diese beiden Operationen durchzuführen?
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Intermezzo - Vergleich mit Array-Operationen
=============================

Erinnern wir uns an die Einführungslektion:

**Arrays sind:**

* ineffizient, wenn man nicht genau weiss, wieviele Elemente zu speichern sind
* ineffizient, wenn man einzelne Elemente einfügen oder entfernen muss
* effizient, wenn man auf beliebige Elemente zugreifen muss

**Listen sind:**

* effizient, wenn man nicht genau weiss, wieviele Elemente zu speichern sind
* effizient, wenn man einzelne Elemente einfügen oder entfernen muss
* ineffizient, wenn man auf beliebige Elemente zugreifen muss


<i class="far fa-hand-point-right"></i> Wir halten also fest:

* Einfüge- und Verschiebe-Operationen in **Listen** sind **billig** (in Rechenzeit)
* Einfüge- und Verschiebe-Operationen in **Arrays** sind **teuer** (in Rechenzeit)
* Direktzugriff auf eine bestimmte Position in **Listen** ist **teuer** (in Rechenzeit)
* Direktzugriff auf eine bestimmte Position in **Arrays** ist **billig** (in Rechenzeit)


<i class="far fa-hand-point-right"></i> Wir müssen also genau überlegen, welche Datenstruktur wir für unser Problem verwenden -
Listen wie auch Arrays sind nicht für alle Problemstellungen gleich gut geeignet!

Wir beschäftigen uns später im Modul noch genauer mit der Effizienz von Algorithmen.
</textarea>
</section>
</section>

<section>
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Denksport-Aufgabe: Schnelles anhängen
=============================

Eine Eigenschaft der Linked Lists ist ja, dass **Einfügen schnell sein soll** - Stimmt dies für unsere `List.append()`-Methode?

* Wie lange dauert das Anhängen mit `append` bei einer leeren Liste?
* Wie lange dauert das Anhängen mit `append` bei einer Listen-Grösse von 10 Elementen?
* ... von 1'000 Elementen?
* ... von 1'000'000 Elementen?

```java
LinkedList<String> liste = new LinkedList<>();
liste.append("1");
liste.append("2");
liste.append("3");
liste.append("4");
// .......
liste.append("10000000");
```
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Denksport-Aufgabe: Schnelles anhängen
=============================

<i class="far fa-hand-point-right"></i> Hier haben wir also ein Problem! Unsere Liste ist gar nicht schnell!
Je länger die Liste wird, desto langsamer wird das Anfügen! Das ist ja wie bei Arrays!

Dagegen müssen wir etwas tun.

** Finden Sie eine Lösung für das Problem**: Das Anfügen eines Elementes soll **immer gleich schnell gehen**,
egal, wie lange die Liste ist!

<i class="far fa-hand-point-right"></i> Entwickeln Sie in den nächsten Minuten eine mögliche Lösung,
und stellen Sie diese den Anderen vor!

</textarea>
</section>
</section>

<section>
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Weitere Methoden für die Liste
=============================

Wir können nun bereits Elemente einfügen, verschieben, entfernen. Um die Liste in der Praxis benutzen zu können,
braucht es noch ein paar Methoden mehr.

Was denken Sie, könnten noch für Methoden nützlich sein, um die Liste in der Praxis benützen zu können?

<div class="fragment">
<p>Folgende Szenarien kommen in der Praxis viel vor:</p>
<ul>
    <li>Sie möchten wissen, **wieviele Elemente** ihre Liste beinhaltet</li>
    <li>Sie möchten einen bestimmten Wert **suchen**, um das `ListNode`-Objekt zu erhalten</li>
    <li>Sie möchten die Liste **leeren**</li>
    <li>Sie möchten Elemente in der Liste **vertauschen** (z.B. zum Sortieren)</li>
    <li>Sie möchten Elemente an einer **bestimmten Position** (Index) auslesen / setzen</li>
</ul>
</div>

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Weitere Methoden für die Liste
=============================

Dies führt zu folgenden zusätzlichen Methoden für unsere `LinkedList`-Klasse:
z.B.:

* eine **`count()`**-Methode, welche die Anzahl Elemente zurückgibt
* eine **`find(Wert)`**-Methode, welche eine Node anhand eines Wertes findet
* eine **`clear()`**-Methode, welche alle Nodes in der Liste entfernt
* eine **`swap(Wert1, Wert2)`**-Methode, welche den Wert1 mit dem Wert2 vertauscht
* eine **`getAt(index)`** und eine **`setAt(index, Wert)`**-Methode, um Werte an Position `index` zu lesen/setzen

<i class="far fa-hand-point-right"></i> Implementieren Sie diese Methoden in der LinkedList-Klasse!

**Bonus-Aufgabe**:

1. Erstellen Sie eine Liste mit beliebigen (zufälligen, siehe `Math.random()`) Werten.
2. Erstellen Sie eine Methode, um das grösste Element zu finden, und geben Sie dieses aus.
3. Verschieben Sie das Element an das Ende der Liste. Sie haben nun bereits den ersten Schritt
   eines Sortier-Algorithmus entwickelt.<br />
   **Double-Bonus**: Wie müssen Sie vorgehen, um die GESAMTE Liste nach diesem Schema zu sortieren, sodass Sie
   am Schluss eine aufsteigend sortierte Liste haben?
   Können Sie dies als Programm umsetzen?
</textarea>
</section>
</section>

{% endblock %}
