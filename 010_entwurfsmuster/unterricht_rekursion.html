{% extends "../_base_template.html" %}
{% block title %}Lektion 10 - Entwurfsmuster, Iteration, Rekursion{% endblock %}

{% block sections %}
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Lektion 10 - Entwurfsmuster, Iteration, Rekursion
=============================

Ziele:

* Sie können ein paar Beispiele von Entwurfsmuster nennen
* Sie verstehen den Verwendungszweck von Entwurfsmustern
* Sie können an bestehendem Source-Code Entwurfsmuster erkennen
* Sie können die rekursive Programmform beschreiben und ihren Nutzen (und Probleme) benennen
* Sie können rekursive und iterative Programmformen unterscheiden
* Sie können einfache, definierte Probleme in rekursiver Form umsetzen
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Rekursion
=============================

Rekursion in der Informatik bedeutet:

> eine definierte Funktion ruft zur Problemlösung sich selber wieder auf.

<i class="far fa-hand-point-right"></i> Auf welche Probleme stossen wir als Programmierer da, wenn wir nicht aufpassen?
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Rekursion
=============================

Rekursion in der Informatik bedeutet:

> eine definierte Funktion ruft zur Problemlösung sich selber wieder auf.

<i class="far fa-hand-point-right"></i> Auf welche Probleme stossen wir als Programmierer da, wenn wir nicht aufpassen?

**Wichtig**: Sie brauchen eine gute Abbruchbedingung, ansonsten ruft sich die Funktion theoretisch bis in alle Ewigkeit auf.

**Beispiel**:

schlechte / falsche Abbruchbedingung:
```java
int log2(float input) {
    if (input / 2 == 1) {
        return 1;
    } else {
        return log2(input / 2) + 1;
    }
}
input(16); // OK, Antwort: 4
input(18); // Oops! läuft ewig, resp. Stack Overflow!
```

Besser (wenn auch falsch):
```java
int log2(float input) {
    if (input / 2 > 1) {
        return log2(input / 2) + 1;
    } else {
        return 1;
    }
}
input(16); // OK, Antwort: 4
input(18); // OK, hört auf (wenn auch falsche Antwort)
```
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Rekursion
=============================

Wo wird Rekursion angewendet? Warum?

**Wann**

* bei funktionalen Programmiersprachen ohne iterative Mittel obligatorisch
* eleganter und "einfacher" Code erwünscht (z.B. bei kompizierten Datenstrukturen, Bäumen)
* gute, präzise Abbruchbedingung ist möglich

**Wann nicht**

* Speicher- und Recheneffizienz ist notwendig
* "unmathematische" Algorithmen - grosse Funktionen. Diese werden durch Rekursion sehr schnell sehr kompliziert.

**Wieso nicht?**

* Durch wiederholten Funktionsaufruf muss der Prozessor immer wieder ein "Context Switch" durchführen - Funktionsaufrufe
  sind Speicher- und Rechenintensiv.
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Rekursion - Beispiel Fakultät (n!)
=============================

`4! = 4 * 3 * 2 * 1`

Allgemein:

* `0! = 1`
* `(n > 0)! = n*(n - 1)!`

Also:

`4! = 4*3! = 4*3*2! = 4*3*2*1! = 4*3*2*1*1`

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Rekursion - Beispiel Fakultät (n!)
=============================

**Was passiert dabei im Speicher?**

Unten ist der "Call Stack" symbolisiert - also die Stufen der Funktionsaufrufe und Zwischenergebnisse.

```
Ziel: 4!
Also: 4! = 4*3!
* ... 3! = 3*2!
    * ... 2! = 2*1!
        * ... 1! = 1*0!
            ... Das wissen wir! 0! ist per Definition 1.
        * 1! ist also 1*1 = 1
    * 2! ist also 2*1*1 = 2
* 3! ist also 3*2*1*1

--> 4! ist also 4*3*2*1*1 = 24
```
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Rekursion - Beispiel Fakultät (n!)
=============================

**Rekursive Umsetzung in Java**

```java
int fac(int n) {
    if (n == 0) {
        return 1;
    } else {
        return n*(fac(n-1));
    }
}
```

Mit der Startzahl 4 würde der Computer somit ausrechnen:

`4*(3*(2*(1*fac(0))));`

<i class="far fa-hand-point-right"></i> Schauen wir uns den Stack Trace in Eclipse an! (Praxis)
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Rekursion - Beispiel Fakultät (n!)
=============================

**Iterative Umsetzung in Java**

Kurze Übung für Zwischendurch: Implementieren Sie `int fac(int n)` in Java als ITERATIVE Variante!

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Rekursion - Beispiel Fakultät (n!)
=============================

**Iterative Umsetzung in Java**

Kurze Übung für Zwischendurch: Implementieren Sie `int fac(int n)` in Java als ITERATIVE Variante!

```java
int fac(int n) {
    int ergebnis = 1;
    for (int i = 1; i <= n; i++) {
        ergebnis = ergebnis * i;
    }
    return ergebnis;
}
```
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Rekursion - Zusammenfassung
=============================

Folgende Fakten sind gegeben:

* Methoden können sowohl interativ ALS AUCH rekursiv umgesetzt werden.
* Rekursion ist für uns schwieriger zu verstehen
* Jede iterative Lösung lässt sich auch rekursiv lösen - und umgekehrt.

**Iteration**

* Durch Schleifen (for, while) gelöst
* Abbruchbedingungen beenden die Schleifen
* Ergebnis wird schrittweise pro Schleifendurchgang erarbeitet
* typischerweise performanter

**Rekursion**

* Methode ruft sich immer wieder selber auf
* Abbruchbedingung beendet die Rekursion
* Ergebnis basiert auf rekursiv ermitteltem Teilergebnis
* Es lässt sich vieles eleganter lösen (= weniger Quellcode)
* Speicherintensiver, da Funktionsaufrufe im Stack zwischengespeichert werden
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-flask"></i> Rekursion - Zusammenfassung
=============================

**Aufgaben zu Entwurfsmuster, Rekursion**

* Thema **Greedy Algorithmus**
  * Setzen Sie eine Funktion `int[] muenzen(int betragInRappen)` um
  * Die Funktion erstellt einen Array mit Münzen (alles in Rappen) zu 5, 10, 20, 50, 100, 200, 500-Stücken
  * Es sollen möglichst wenig Münzen zurückgegeben werden, welche zusammen den Betrag in Rappen ergeben
  * Bsp: `muenzen(145) = [100, 20, 20, 5]`

* Thema Rekursion - Was passiert auf dem Stack? Arbeiten Sie das Kapitel **13.5** - Implementation im Stack - vom Inauen-Script durch!

* Thema Rekursion - grösster gemeinsamer Teiler
  * Setzen Sie die Funktion `int ggT(int x, int y)` ITERATIV um
  * Setzen Sie die Funktion `int ggT(int x, int y)` REKURSIV um
  * Siehe https://de.wikipedia.org/wiki/Euklidischer_Algorithmus
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-flask"></i> Rekursion - Aufgaben
=============================

**Unbekannter Algorithmus**

Betrachten Sie folgenden Pseudo-Code:

```
Funktion f(nr, Liste l):
    act := 2
    Erhöhe act solange um 1, bis nr ohne Rest durch act teilbar ist.
    Dann act in Liste l aufnehmen.
    div := nr / act
    ist div > 2?
    wenn ja:
        rekursiv f(div, Liste l) aufrufen
    wenn nein:
        div in Liste l
    Ergebnis: Liste l
```

* Setzen Sie diesen Pseudo-Code in Java um. Verwenden Sie als Liste z.B. eine LinkedList
* Was macht dieser Code? Versuchen Sie, durch verschiedene Werte von `nr` und Analyse der Liste l, dies herauszufinden!
* Berechnen Sie die Komplexitätsklasse!
  * Was ist die Eingabegrösse?
  * Was ist der Worst Case?
  * Wie gross ist O(n) für nr = Primzahlen?
  * Wie gross ist O(n) für nr = Exponenten von 2 (z.B. 2^8 = 256)
  * Wie lautet `O(f(nr,liste)) = O(?)`?
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-flask"></i> Rekursion - Anwendung - Maze Solver!
=============================

**Maze Solver!**

Auf Moodle finden Sie ein Java-Programm, welches einen Lösungsalgorithmus für einen Irrgarten aufzeigt (MazeSolver.zip).
Das Programm löst ein Irrgarten:

```
██████████████████E█
█ █     ███   ████ █
█   █████████ ██   █
███ █       █ █  ███
█   █ █ ███ █ █ ████
█ █████ ███   █ █  █
█   ██   ████ █ █ ██
█ ██ █ █ ██ █ █    █
█      █    █   ██ █
████ ███████████████
```

**Aufgaben**

1. Schauen Sie sich das Programm, im Speziellen die Funktion `solve()` an. Verstehen Sie, was da passiert?
2. Beantworten Sie folgende Fragen:
   * Ist dies ein **Greedy Algorithmus**?
   * Ist dies ein **Backtracking Algorithmus**?
   * Sehen Sie hier die Anwendung von **Divide and Conquer**?
   * Ist dies ein rekursiver oder iterativer Algorithmus?
   * Welche Komplexität weist dieser Algorithmus auf?
3. Verändern Sie das Labyrinth:
   * Was passiert, wenn Sie den Start auf das "innere" des Irrgartens verlegen? (siehe main(), Zeile 150, ms.solve() definiert den Start )
   * Kriegen Sie "unlösbare" Irrgärten hin?
</textarea>
</section>
{% endblock %}
