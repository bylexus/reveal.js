{% extends "../_base_template.html" %}
{% block title %}Lektion 3 - Linked Lists{% endblock %}

{% block sections %}
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Lektion 3 - Grundlagen Linked Lists
=============================

Ziel der Lektion:

* Sie können Klassen als komplexe Datenstrukturen in Java nutzen
* Sie wissen, was Referenzvariablen sind und wie diese mit Objekten im Speicher zusammenhängen
* Sie verstehen den Aufbau einer Linked List
* Sie können eine Linked List in Java als Container-Klasse selber programmieren

</textarea>
</section>

<section>
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> komplexe Datentypen - zur Erinnerung
=============================

Wir repetieren kurz:

* Komplexe Datentypen in Java bilden wir mit Klassen ab.
* Klassen sind "Baupläne" für spätere Objekt-Instanzen
* Klassen bestehen aus **Attributen** und **Methoden**

<i class="far fa-hand-point-right"></i> Mehr dazu im Modul von Herrn Inauen.

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> komplexe Datentypen - zur Erinnerung
=============================

Ein Beispiel eines komplexen Datentyps mit Klassen:

```java
class Noten {
    public String schueler;
    public float[] noten = new float[10];
    public float summe() {
        float s = 0;
        for(int i = 0; i < this.noten.length; i++) {
            s = s + this.noten[i];
        }
        return s;
    }
}

// Instanzieren eines Objektes: vom "Bauplan" Klasse wird ein Objekt "gebaut":
Noten n = new Noten();
// Attribute zuweisen / verändern:
n.schueler = "Alexander";
n.noten[0] = 5;
n.noten[2] = 4;

// Methoden anwenden:
float schnitt = n.summe() / n.noten.length;
```
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Repetition Referenzen in Java
=============================

**Zur Erinnerung:**

Komplexe Datentypen / Objekte werden im Heap abgelegt, und man erhält eine **Referenzvariable** (einfach gesagt: ein Pointer)
auf dem Stack:

<img src="../001_start/stack_heap.png" width="300"/>

Beispiel:
```java
// n1 ist die Referenzvariable auf dem Stack auf ein Objekt im Heap vom Typ "Noten":
Noten n1 = new Noten();
n1.schueler = "Alexander";

// n2 kriegt die Referenz zugewiesen, zeigt somit auf dasselbe Objekt:
Noten n2 = n1;
n2.schueler = "Thomas";

System.out.println(n1.schueler); // Ausgabe?
System.out.println(n2.schueler); // Ausgabe?
```
</textarea>
</section>
</section>


<section>
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Grundlagen Listen
=============================

**Folgendes gilt es festzuhalten:**

Arrays sind (ineffizient / efffizient):

* <span class="fragment"> ineffizient</span>, wenn man nicht genau weiss, wieviele Elemente zu speichern sind
* <span class="fragment"> ineffizient</span>, wenn man einzelne Elemente einfügen oder entfernen muss
* <span class="fragment"> effizient</span>, wenn man auf beliebige Elemente zugreifen muss

<i class="far fa-hand-point-right"></i> Wir können also nicht für alle Probleme einfach Arrays benützen:
Muss viel eingefügt / entfernt werden, oder wissen wir noch nicht genau, wieviel wir speichern wollen,
sind **Arrays ineffizient, sprich, langsam und speicherintensiv**.
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Grundlagen Listen
=============================

Schauen wir uns deshalb eine weitere **Datenstruktur** an: Die **Verketteten Listen**.

<i class="far fa-hand-point-right"></i> Wir schauen uns dies mit LEGO<sup>&reg;</sup>-Steinen an:
* grundlegender Aufbau: Liste, List-Node (Element)
* welche Eigenschaften hat eine Liste?
* wie sind Listen / Elemente im Speicher abgelegt?
* können Sie Elemente an beliebiger Stelle einfügen / entfernen?
* können Sie Listen erweitern / kürzen?
* wie fügen Sie neue / weitere Elemente ein?
* wie entfernen Sie Elemente aus der Liste?
* Zusammenfassend: Was ist gut (einfach, schnell), was ist nicht gut (kompliziert, langsam) an Listen?

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Grundlagen Listen
=============================

**Folgendes gilt es festzuhalten:**

Arrays sind:

* ineffizient, wenn man nicht genau weiss, wieviele Elemente zu speichern sind
* ineffizient, wenn man einzelne Elemente einfügen oder entfernen muss
* effizient, wenn man auf beliebige Elemente zugreifen muss

Listen sind:

* effizient, wenn man nicht genau weiss, wieviele Elemente zu speichern sind
* effizient, wenn man einzelne Elemente einfügen oder entfernen muss
* ineffizient, wenn man auf beliebige Elemente zugreifen muss

**Definition Liste:**

> <i class="far fa-hand-point-right"></i> Eine verkettete Liste ist eine Datenstruktur, die eine unbestimme Anzahl von
(komplexen) Datentypen enthält. Dieser Datentyp dient der Speicherung von Daten.
Die aus diesen Datentypen erzeugten Datenstrukturen werden "Knoten" oder **Nodes** genannt. Die einzelnen Knoten der Liste sind
dabei durch Referenzen (resp. Pointer) verbunden.

</textarea>
</section>
</section>



<section>
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Einfach verkettete Liste - Grafisch
=============================

Listen bestehen aus einzelnen **List Nodes**, welche miteinander über Referenzen / Pointer verbunden sind:

<img src="single_linked_list.png" width="500"/>

Sie sehen hier einen **komplexen Datentyp**, eine Klasse **ListNode**, welche:

1. einen Datenwert, hier eine Integer-Zahl speichern kann
2. "seine" Nachbar-Node (next), also die nächste Node in der Liste, kennt.
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Einfach verkettete Liste - Code
=============================

Wir definieren eine `ListNode`-Klasse als komplexen **Container**-Datentyp in Java:

```java
class ListNode<T> {
    // "Wert" der Node: das "T" steht für einen beliebigen Datentyp: Wir speichern also
    // eine Referenz auf "etwas":
    public T data;

    // Referenz / Zeiger auf die nächste Node:
    public ListNode<T> next;
}
```

**"T"** steht hier für einen Platzhalter eines Datentyps: Wie auch bei Arrays ist es der
Liste "egal", welchen Datentyp sie aufnimmt: Wir nennen ihn einfach "T". Erst bei der
Verwendung durch den Programmierer müssen wir uns auf einen Datentypen festhalten.
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Doppelt verkettete Liste - Grafisch
=============================

Doppelt verkettete Listen kennen ihre "Nachbarn" in beide Richtungen:

<img src="double_linked_list.png" width="500"/>

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Doppelt verkettete Liste - Code
=============================

Wir definieren eine doppelt verlinkte `ListNode`-Klasse als komplexen Container-Datentyp:


```java
class ListNode<T> {
    // "Wert" der Node: das "T" steht für einen beliebigen Datentyp: Wir speichern also
    // eine Referenz auf "etwas":
    public T data;

    // Referenz / Zeiger auf die vorherige / nächste Node:
    public ListNode<T> next;
    public ListNode<T> prev;
}
```

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Verkettete Liste - Anwendung
=============================

Die `ListNode`-Klasse können wir nun instanzieren und verketten:

```java
// ListNodes erstellen, mit Daten vom Typ (Klasse) "Integer" füllen:
ListNode<Integer> node1 = new ListNode<>();
node1.data = 1;

ListNode<Integer> node2 = new ListNode<>();
node2.data = 2;

// Nodes miteinaner verknüpfen:
node1.next = node2;
node2.prev = node1;
```

Damit haben wir bereits eine verkettete Liste! Dies ist natürlich noch nicht sehr
anwenderfreundlich: Wir möchten mit Listen ja ähnlich umgehen wie mit Arrays...

</textarea>
</section>
</section>


<section>
<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Aufbau / Methoden
=============================

Vergleich mit "Menschenkette":

<img src="human_chain.png" width="400" />

* Ist das nicht auch einfach eine "Datenstruktur" (aus Menschen)?
* Was passiert, wenn eine neue Person an einer bestimmten Stelle "eingefügt" wird?
* Was passiert, wenn eine Person aus der Reihe entfernt wird?

<i class="far fa-hand-point-right"></i> Wir haben also ein paar Anforderungen, was wir mit der Liste machen können müssen:

* wir wollen einen neuen Wert **anfügen** (engl: to append)
* wir wollen einen neuen Wert an einer bestimmten Stelle **einfügen** (engl: to insert)
* wir wollen einen bestehenden Wert / Node **entfernen** (engl: to remove)
* wir wollen alle Elemente **durchlaufen**, also etwas tun mit den einzelnen Werten

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Aufbau / Methoden
=============================

** Funktionen**

Folgende Anforderungen haben wir:

* Liste verwalten: wir wollen ähnlich "komfortabel" mit einem Typ "Liste" arbeiten, nicht mit einzelnen ListNodes
* Wert am Schluss einfügen: Element (Node) anhängen
* Wert zwischendrin einfügen: Element (Node) einfügen
* Wert in der Liste verschieben
* Wert / Element (Node) entfernen
* Liste ausgeben / durchlaufen

... ergibt:

* die Datenstruktur **`List`** definieren: Sie repräsentiert die Liste als Ganzes:
* `List` ist verantwortlich für das Verwalten der einzelnen `ListNodes`
* sie kennt (nur) den Anfang (engl: `head`) der Liste, also die vorderste `ListNode`
* **`append(Wert)`** dient zum Anhängen einer ListNode, resp. eines Wertes
* **`insert(Wert, Wert)`** dient zum Einfügen einer ListNode, resp. eines Wertes
* **`move(Wert, Wert)`** dient zum Verschieben einer ListNode, resp. eines Wertes
* **`remove(Wert)`** dient zum Entfernen einer ListNode, resp. eines Wertes
* **`printList()`** dient zum Ausgeben der Elemente der Liste

</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Aufbau / Methoden: List-Klasse
=============================

Wir definieren also unsere `List`-Klasse, welche:
* unsere Liste als Ganzes repräsentiert:
  * Sie ist eine Container-Klasse, welche als Werte einen beliebigen komplexen Datentyp `T` speichern kann
  * Sie besitzt eine Referenz auf die **erste ListNode**
  * Sie stellt die gewünschten Methoden zum Bearbeiten der Liste zur Verfügung

Ich zeige Ihnen hier den grundlegenden Aufbau der **List**-Klasse, und
die Implementation der Methode `append`:

```java
public class LinkedList<T> {
	// Eine Referenz / Pointer auf die erste Node unserer Liste
	public ListNode<T> head;

	public ListNode<T> append(T newValue) {
		// Unseren Wert, newValue, "verpacken" wir in eine ListNode,
		// welche wir dann am Schluss der Liste, also an der letzten ListNode anhängen:
		ListNode<T> newNode = new ListNode<>();
		newNode.data = newValue;

		// Anhängen heisst: am Schluss der Liste anfügen. Wir suchen also
		// den "Schwanz" der Liste, indem wir von vorne bis zum Schluss
		// durch die Liste "hangeln":
		ListNode<T> last = head;
		while( last != null && last.next != null ) {
			last = last.next;
		}

		// Wir haben noch keine "letzte" Node, da unsere neue Node die erste ist:
		if (last == null) {
			this.head = newNode; // unsere neue Node wird zum "Head"
			newNode.prev = null;
		}
		// Wir haben bereits eine "letzte" Node, hängen wir die neue hinten dran:
		else {
			last.next = newNode;
			newNode.prev = last;
		}

		// next auf unserer neuen Node ist sicher null (da am Schluss der Liste):
		newNode.next = null;

		return newNode;
	}
}

```
</textarea>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Aufbau / Methoden: List-Klasse
=============================

Nun können wir die `List`-Klasse bereits anwenden,
und mit Werten, eingepackt in `ListNode`Objekte, füllen:

```java
public class Main {
	public static void main(String[] args) {
        // Neue LinkedList instanzieren:
		LinkedList<Integer> l = new LinkedList<>();

		// Neue Werte einfügen: nun schon recht komfortabel:
		l.append(1);
		l.append(2);
		l.append(3);

		// Liste durchlaufen (noch nicht so komfortabel):
		ListNode<Integer> actNode = l.head;
		while (actNode != null) {
			System.out.println(actNode.data);
			actNode = actNode.next;
		}
	}
}
```
</textarea>
</section>
</section>

<section data-markdown >
<textarea data-template>
<i class="fas fa-graduation-cap"></i> Aufbau / Methoden: List-Klasse
=============================

Die weiteren Funktionen programmieren und testen Sie selber (jetzt, Hausaufgabe)

Ich schlage folgende Reihenfolge vor:

* die **`ListNode`**-Klasse muss implementiert werden:
    * **`append(Wert)`** fertig: Bringen Sie das Programm zum Laufen
    * **`printList()`**
    * **`insert(Wert a, Wert b)`** (neuer Wert a, Einfügen nach Wert b)
    * **`remove(Wert)`** (zu entfernender Wert)
    * **`move(Wert a, Wert b)`** als Kombination der vorhergehenden Methoden.

<i class="far fa-hand-point-right"></i> Sie finden das Grundgerüst für `List` und `ListNode`
auf Moodle.
</textarea>
</section>
</section>
{% endblock %}
